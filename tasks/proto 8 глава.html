<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // В приведённом ниже коде создаются и изменяются два объекта.
    //
    //     Какие значения показываются в процессе выполнения кода?
    // let animal = {
    //     jumps: null
    // }
    // let rabbit ={
    //     __proto__: animal,
    //     jumps: true
    // }
    //
    // console.log(rabbit.jumps) // true
    // console.log(animal.jumps) // null
    // console.log(rabbit)
    // delete rabbit.jumps
    // console.log(rabbit.jumps) // null
    // console.log(rabbit)
    // delete animal.jumps
    // console.log(rabbit.jumps) // undefined


    // С помощью свойства __proto__ задайте прототипы так, чтобы поиск любого свойства выполнялся по следующему пути:
    // pockets → bed → table → head.
    //     Например, pockets.pen должно возвращать значение 3 (найденное в table), а bed.glasses – значение 1 (найденное в head).


    // let head = {
    //     glasses: 1
    // };
    //
    // let table = {
    //     pen: 3
    // };
    //
    // let bed = {
    //     sheet: 1,
    //     pillow: 2
    // };
    //
    // let pockets = {
    //     money: 2000
    // };

    // let head = {
    //     glasses: 1,
    // };
    //
    // let table = {
    //     pen: 3,
    //     __proto__:head
    // };
    //
    // let bed = {
    //     sheet: 1,
    //     pillow: 2,
    //     __proto__:table
    // };
    //
    // let pockets = {
    //     money: 2000,
    //     __proto__:bed
    // };
    // console.log(pockets.pen) // 3: pockets -> bed -> table (pen: 3)
    // console.log(bed.glasses) // 1: bed -> table -> head (glasses: 1)




    // Объект rabbit наследует от объекта animal.
    //     Какой объект получит свойство full при вызове rabbit.eat(): animal или rabbit?

    // let animal = {
    //     eat() {
    //         this.full = true;
    //     }
    // };
    //
    // let rabbit = {
    //     __proto__: animal
    // };
    //
    // rabbit.eat(); //rabbit потому что свойство получит тот объект который стоит перед . (перед вызовом метода)



    let hamster = {
        stomach: [],

        eat(food) {
    if (!this.stomach){
        this.stomach.push(food);
    }

        }
    };

    let speedy = {
        __proto__: hamster,

    };

    let lazy = {
        __proto__: hamster,

    };

    // Этот хомяк нашёл еду
    speedy.eat("apple");
    console.log( speedy.stomach ); // apple

    // У этого хомяка тоже есть еда. Почему? Исправьте // потому что получается что один stomach на 2 объекта. если указывать свойства который описывают состояние обхекта в каждый отдельный объект то будет все норм
    console.log( lazy.stomach ); // apple



</script>

</body>
</html>